#  TODO (for v2.0)

1. Unify prime factors, modulo, encryption exponent and decryption exponent into a single `Keys` object. `keys.pub` and `keys.priv` would then be of type `TransformationParameters`. The initializer for `Keys` would already generate the exponents for encryption and decryption. Also, instead of testing random numbers for coprimality with (p - 1)(q - 1), we would simply try to invert each candidate modulo (p - 1)(q - 1). On failure, we pick a new random number. On success, we already get the decryption exponent. This would compress two Euclides's algorithm calls into a single one. It would also mean the decryption step cannot fail, so the decrypted message would no longer have to be optional. 
1. There should be an additional method in `Keys` to check compatibility with the encryption parameters used. This would simply compare the encryption exponent and the modulo for equality.
1. There should be a correctness check for `Keys`. As long as we don't check the primality of the factors, everything else should be very fast because the encryption and decryption exponents are stored in it. We would simply check that both exponents are in the right interval and that their product is congruent to 1 modulo (p - 1)(q - 1). No Euclides needed.
1. The encrypted message object should include a parameter saying whether the original message was of type `Data` or `String`. When decrypting, the result can be an enum value where one case corresponds to `Data` and contains a `Data` object, while the other case is the analogous for `String`. Another interesting idea would be to use overloads that differ only by the return type. In this case, both the `Data` and the `String` case could have the same function name `decrypt` and same signature except for the return type. The disadvantage is that Bob would still have to know which one to use, because you have to explicitly type the object where the returned value will be stored, as in `let message: String = decrypter.decrypt(...)`. The advantage would be that it looks more elegant than returning enum values. The third idea would be to only work with strings, but this sucks too.
1. Separate encryption and decryption into different files.
1. Turn the playground into a playground book, with lots of markdown in the comments, and different parts of the message exchange on different pages. Use resources to provide examples where data files are encrypted (preferrably images, which can be shown on the playground as well). Take a look at Ole Begemann's `whats-new-in-swift-4` playground book. 
1. In the playground, perhaps use some configuration of the json encoder (e.g. `.prettyPrinted`). Maybe it can be initialized once and used throughout the whole playground.
1. Adopt the newest swift features. For example, get rid of unnecessary `fileprivate` declarations.
1. Clean up the code. Re-organize the files. Make it clearer what the public interface is and separate it better from the implementation details. Currently, the files with protocols contain too many protocols, plus some structs, plus some extensions etc. It's too much.  
1. Solve the issues with random UInt so we never have to work with UInt32.
1. Search for both prime factors within a fixed range, independently from each other.
