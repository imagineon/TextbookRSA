#  TODO (for v2.0)

1. Unify prime factors, modulo, encryption exponent and decryption exponent into a single `Keys` object. `keys.pub` and `keys.priv` would then be of type `TransformationParameters`. The initializer for `Keys` would already generate the exponents for encryption and decryption. Also, instead of testing random numbers for coprimality with (p - 1)(q - 1), we would simply try to invert each candidate modulo (p - 1)(q - 1). On failure, we pick a new random number. On success, we already get the decryption exponent. This would compress two Euclides's algorithm calls into a single one. It would also mean the decryption step cannot fail, so the decrypted message would no longer have to be optional. 
1. There should be an additional method in `Keys` to check compatibility with the encryption parameters used. This would simply compare the encryption exponent and the modulo for equality.
1. There should be a correctness check for `Keys`. As long as we don't check the primality of the factors, everything else should be very fast because the encryption and decryption exponents are stored in it. We would simply check that both exponents are in the right interval and that their product is congruent to 1 modulo (p - 1)(q - 1). No Euclides needed.
1. The encrypted message object should include a parameter saying whether the original message was of type `Data` or `String`. When decrypting, the result can be an enum value where one case corresponds to `Data` and contains a `Data` object, while the other case is the analogous for `String`.
1. Separate encryption and decryption into different files.
1. Turn the playground into a playground book, with lots of markdown in the comments, and different parts of the message exchange on different pages. Use resources to provide examples where data files are encrypted (preferrably images, which can be shown on the playground as well). Take a look at Ole Begemann's `whats-new-in-swift-4` playground book. 
